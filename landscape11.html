<!DOCTYPE html>
<html lang="en">
	<head>
		<title>landscap</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>

			@font-face {
				font-family: Graphik-load;
				
			 	src: url('font/Graphik-Thin.otf') 
				 
			}
			html {
			  background: #333;
			 
			 
			}
			body {
				color: #71544e;
			 
				font-size:13px;
				text-align:center;
				font-family: Graphik-load;
				background-color: #bfd1e5;
				margin: 0px;
				overflow: hidden;
			}
            â‰ˆ
			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #b07861;
			}

			.stopwatch {
			  font-size: 1.5vw;
              font-family: Graphik-load;
              background-color: #000000;
			  height: 5%;
			  color:#cecece; 
			 
			  text-align: center;
		 
    		  padding:  1.2vh 0.7vw 0.0vh 0.7vw;
			}

		</style>
	</head>



	<body>

		<div id="container"><br /><br /><br /><br /><br />Generating...</div>
	    `
		<script src="js/build/three.min.js"></script>
		 
        <script src="js/controls/OrbitControls.js"></script>
		<script src="js/renderers/Projector.js"></script>
		<script src="js/renderers/CanvasRenderer.js"></script>

		<script src="js/libs/stats.min.js"></script>
 
		<script src="font/Graphik_Black_Regular.js"></script>
		<script src="font/Graphik_Light_Regular.js"></script>
        	<script id="fragmentShader" type="x-shader/x-fragment">

				const float MAX_NUM_MILES = 9.0;
				const float MAX_DOT = 45.0;
				const float PI = 3.141592653589793238462643383279;
				const float MAX_INTENSITY = 500.0;
				const float MIN_INTENSITY_THICKNESS = 0.03;
				const float MAX_INTENSITY_THICKNESS = 0.11;

				uniform vec4 uFrontColor;
				uniform vec4 uBackColor;
				uniform float uIsSolid;
				uniform float uHighlightCenter;

				uniform float uNumOfMiles;
				uniform float uActiveDist;
				uniform float uRPM;
				uniform float uIntensity;
				uniform float uTransparent;
				uniform float uMileStoneAnimTime;

				varying vec2 vUV;
				varying vec2 vRotatedUV;

				float circle(vec2 center , float radius, float thickness, float la,float ha, float angle, float isSmooth)
				{
					float f = length(center);
					float a = atan(center.y, center.x);
					float smooth = 0.02;
					if ( isSmooth == 1. ) {
						return(	smoothstep(f,f+smooth,radius)
							  * smoothstep(radius - thickness,radius - thickness+smooth,f)
							  * smoothstep(la,la+smooth,a) * smoothstep(a-smooth,a,ha));
					} else {
						return( smoothstep(f,f+smooth,radius)
							  * smoothstep(radius - thickness,radius - thickness+smooth,f)
							  * step(la,a)*step(a,ha));
					}
				}

				float dotCircle (vec2 center, float radius, float thickness, float dotNum, float dotGap )
				{
					float f = length(center);
					float a = atan(center.y, center.x);
					float t = radius - thickness;
					float twoPI = PI * 2.0;
					float seg = twoPI / dotNum;
					float dotMod = mod ( a, seg );
					float dot = 0.0;
					float gap = seg - dotGap;
					dot = smoothstep( dotMod, dotMod+0.02, gap ) * smoothstep( 0.0, 0.02, dotMod );
					float ret = smoothstep(f, f+0.02, radius);
					if(t > 0.0) {
					  ret *= smoothstep( t, t + 0.01, f );
					}
					if(dotGap > 0.0) {
					  ret *= dot;
					}
					return ret;
				}

				void main( )
				{
					vec2 p = -1.0 + 2.0 * vUV;
					vec2 rp = -1.0 + 2.0 * vRotatedUV;
					float f = 0.0;
					float b = 0.0;
					float animDistanceCircleMixer = 0.0;
					float twoPI = 2.0 * PI;
					float halfPI = PI * 0.5;
					float intensityWheelRad = 0.35;
					float thick = mix ( 0.0, MAX_INTENSITY_THICKNESS, clamp( uIntensity/MAX_INTENSITY, 0.0, 1.0 ) );
					float intensity = floor( MAX_DOT - min( (uIntensity/MAX_INTENSITY) * (MAX_DOT - 4.0), MAX_DOT - 4.0 ) );
					float dotGap = 0.08;
					vec4 solidColor = vec4(uBackColor.rgb, 1.0);
					
					if (uMileStoneAnimTime > 0.0) {
						f += dotCircle( rp, intensityWheelRad, intensityWheelRad, 1.0, 0.0 );
						f += dotCircle( rp, intensityWheelRad, max( MIN_INTENSITY_THICKNESS+thick, intensityWheelRad * clamp(uMileStoneAnimTime, 0.0, 1.0)), 1.0, 0.0 );
					} else {
						f += dotCircle( rp, intensityWheelRad, MIN_INTENSITY_THICKNESS+thick, intensity, dotGap );
					}

					b += dotCircle(rp, intensityWheelRad+0.03, intensityWheelRad+0.03, 1.0, 0.0 );
					vec4 backColor;
					if ( uTransparent == 1.0 ) {
						backColor = uBackColor;
					} else {
						backColor = mix ( uBackColor, solidColor, b );
					}
					if ( uHighlightCenter == 1.0 ) {
						vec4 innerColor = vec4(uFrontColor.rgb, 1.0);
						float inner = 0.0;
						inner += dotCircle(rp, intensityWheelRad-0.15, intensityWheelRad-0.15, 1.0, 0.0 );
						backColor = mix ( backColor, innerColor, inner );
					}

					thick = 0.0734;
					float radius = intensityWheelRad + thick;
					for (float i = 0.; i < MAX_NUM_MILES; i++) {
				    	if ( i <= uNumOfMiles ) {
				    		float lineThick = thick * 0.85;
				    		//lineThick = 0.5;
					    	if ( i == uNumOfMiles ) {
					    		f += circle( p, radius, lineThick, PI - PI * (uActiveDist * 2.0), PI, halfPI, 1.0 );
					    	} else {
					    		if ( uMileStoneAnimTime == 0.0 || (i+1.0) < uMileStoneAnimTime ) {
					    			f += circle( p, radius, lineThick, -PI, PI, halfPI, 0.0 );
								} else {
					        		animDistanceCircleMixer += circle( p, radius, lineThick, -PI, PI, halfPI, 0.0 ) * ( 0.5 + (clamp( uMileStoneAnimTime - i, 0.0, 1.0 ) * 0.5));
						    	}
							}
							radius += thick;
						}
					}

					vec4 col = mix( backColor, uFrontColor, animDistanceCircleMixer);
					if (uIsSolid == 0.0){
						col += mix( backColor, uFrontColor, f );
					}

					gl_FragColor = col;
				}

		</script>

		<script id="vertexShader" type="x-shader/x-vertex">

			uniform float uTime;
			uniform float uRotation;

			varying vec2 vRotatedUV;
			varying vec2 vUV;

			vec2 rotate ( vec2 v, float angle, vec2 offset ) {
				float sinf = sin( angle );
				float cosf = cos( angle );

				mat2 rotationMatrix = mat2( cosf, -sinf, sinf, cosf );
				return ((v - offset) * rotationMatrix)+offset;
			}

			void main() {
				vec2 offset = vec2(0.5, 0.5);
				float offsetRot = 1.57079632679;

				vRotatedUV = rotate (uv, uRotation, offset);

				vUV = rotate(uv, offsetRot, offset);

				vec4 pos = vec4(position, 1.0);
				gl_Position = projectionMatrix * modelViewMatrix * pos;
			}


		</script>

		<script id="fragmentShaderPast" type="x-shader/x-fragment">
  			
          const float MAX_NUM_MILES = 9.0;
				const float MAX_DOT = 45.0;
				const float PI = 3.141592653589793238462643383279;
				const float MAX_INTENSITY = 500.0;
				const float MIN_INTENSITY_THICKNESS = 0.03;
				const float MAX_INTENSITY_THICKNESS = 0.11;

				uniform vec4 uFrontColor;
				uniform vec4 uBackColor;
				uniform float uIsSolid;
				uniform float uHighlightCenter;

				uniform float uNumOfMiles;
				uniform float uActiveDist;
				uniform float uRPM;
				uniform float uIntensity;
				uniform float uTransparent;
				uniform float uMileStoneAnimTime;

				varying vec2 vUV;
				varying vec2 vRotatedUV;

				float circle(vec2 center , float radius, float thickness, float la,float ha, float angle, float isSmooth)
				{
					float f = length(center);
					float a = atan(center.y, center.x);
					float smooth = 0.02;
					if ( isSmooth == 1. ) {
						return(	smoothstep(f,f+smooth,radius)
							  * smoothstep(radius - thickness,radius - thickness+smooth,f)
							  * smoothstep(la,la+smooth,a) * smoothstep(a-smooth,a,ha));
					} else {
						return( smoothstep(f,f+smooth,radius)
							  * smoothstep(radius - thickness,radius - thickness+smooth,f)
							  * step(la,a)*step(a,ha));
					}
				}

				float dotCircle (vec2 center, float radius, float thickness, float dotNum, float dotGap )
				{
					float f = length(center);
					float a = atan(center.y, center.x);
					float t = radius - thickness;
					float twoPI = PI * 2.0;
					float seg = twoPI / dotNum;
					float dotMod = mod ( a, seg );
					float dot = 0.0;
					float gap = seg - dotGap;
					dot = smoothstep( dotMod, dotMod+0.02, gap ) * smoothstep( 0.0, 0.02, dotMod );
					float ret = smoothstep(f, f+0.02, radius);
					if(t > 0.0) {
					  ret *= smoothstep( t, t + 0.01, f );
					}
					if(dotGap > 0.0) {
					  ret *= dot;
					}
					return ret;
				}

				void main( )
				{
					vec2 p = -1.0 + 2.0 * vUV;
					vec2 rp = -1.0 + 2.0 * vRotatedUV;
					float f = 0.0;
					float b = 0.0;
					float animDistanceCircleMixer = 0.0;
					float twoPI = 2.0 * PI;
					float halfPI = PI * 0.5;
					float intensityWheelRad = 0.35;
					float thick = mix ( 0.0, MAX_INTENSITY_THICKNESS, clamp( uIntensity/MAX_INTENSITY, 0.0, 1.0 ) );
					float intensity = floor( MAX_DOT - min( (uIntensity/MAX_INTENSITY) * (MAX_DOT - 4.0), MAX_DOT - 4.0 ) );
					float dotGap = 0.08;
					vec4 solidColor = vec4(uBackColor.rgb, 1.0);
					
					if (uMileStoneAnimTime > 0.0) {
						f += dotCircle( rp, intensityWheelRad, intensityWheelRad, 1.0, 0.0 );
						f += dotCircle( rp, intensityWheelRad, max( MIN_INTENSITY_THICKNESS+thick, intensityWheelRad * clamp(uMileStoneAnimTime, 0.0, 1.0)), 1.0, 0.0 );
					} else {
						f += dotCircle( rp, intensityWheelRad, MIN_INTENSITY_THICKNESS+thick, intensity, dotGap );
					}

					b += dotCircle(rp, intensityWheelRad+0.03, intensityWheelRad+0.03, 1.0, 0.0 );
					vec4 backColor;
					if ( uTransparent == 1.0 ) {
						backColor = uBackColor;
					} else {
						backColor = mix ( uBackColor, solidColor, b );
					}
					if ( uHighlightCenter == 1.0 ) {
						vec4 innerColor = vec4(uFrontColor.rgb, 1.0);
						float inner = 0.0;
						inner += dotCircle(rp, intensityWheelRad-0.15, intensityWheelRad-0.15, 1.0, 0.0 );
						backColor = mix ( backColor, innerColor, inner );
					}

					thick = 0.0734;
					float radius = intensityWheelRad + thick;
					for (float i = 0.; i < MAX_NUM_MILES; i++) {
				    	if ( i <= uNumOfMiles ) {
				    		float lineThick = thick * 0.85;
				    		//lineThick = 0.5;
					    	if ( i == uNumOfMiles ) {
					    		f += circle( p, radius, lineThick, PI - PI * (uActiveDist * 2.0), PI, halfPI, 1.0 );
					    	} else {
					    		if ( uMileStoneAnimTime == 0.0 || (i+1.0) < uMileStoneAnimTime ) {
					    			f += circle( p, radius, lineThick, -PI, PI, halfPI, 0.0 );
								} else {
					        		animDistanceCircleMixer += circle( p, radius, lineThick, -PI, PI, halfPI, 0.0 ) * ( 0.5 + (clamp( uMileStoneAnimTime - i, 0.0, 1.0 ) * 0.5));
						    	}
							}
							radius += thick;
						}
					}

					vec4 col = mix( backColor, uFrontColor, animDistanceCircleMixer);
					if (uIsSolid == 0.0){
						col += mix( backColor, uFrontColor, f );
					}

					gl_FragColor = col;
				}
	 
		</script>

        <script id="vertexShaderPast" type="x-shader/x-vertex">

        	uniform float uTime;
			uniform float uRotation;

			varying vec2 vRotatedUV;
			varying vec2 vUV;

			vec2 rotate ( vec2 v, float angle, vec2 offset ) {
				float sinf = sin( angle );
				float cosf = cos( angle );

				mat2 rotationMatrix = mat2( cosf, -sinf, sinf, cosf );
				return ((v - offset) * rotationMatrix)+offset;
			}

			void main() {
				vec2 offset = vec2(0.5, 0.5);
				float offsetRot = 1.57079632679;

				vRotatedUV = rotate (uv, uRotation, offset);

				vUV = rotate(uv, offsetRot, offset);

				vec4 pos = vec4(position, 1.0);
				gl_Position = projectionMatrix * modelViewMatrix * pos;
			}

		</script>

		<script>
            
			var defaultSpeed=0.6;
			var speed=defaultSpeed;
			var container, stats;
            var clock = new THREE.Clock();
			var camera, scene;
			var cameraOrtho, sceneRenderTarget;
			var mouseX = 0, mouseY = 0;
		   	var scene2;
        
            var printMaterial;
            var roadMaterial;
            var quality=2;
            var step=1;
            var dataW=1.5, dataH=15;
            var scaleW=30;
            var scaleH=1;
            var visible=true;
            var reset=true;
            
            var GeneralLineW=3;

            var circle 
            var uniforms
            var uniformsPast
            var totalH=0;
            var roadCase=1;
            var CurrentroadCase=1;

            var Percentage=0;
            var incrementer = .01;

			var  globalLineWidthAdd=0.0;
			var  curveList=[];
             
            var passTotal=7;
			var passCount=2;

			var parent;
			var MaterialCPast

            var roundCount=0;
            var countdown=0;

            var textMesh;
            var boardTex;
            var billBoard;
            var stop_Watch;

            var timePeriod=[5,20,35,40];
            var recordList=[];
            var recordTemp

			var billBoardList=[];
            var roadMeshList=[];
            var heightForceChange=true;
			var roadTex;
			var groundLines=[];
			var Gates=[];
            var mileMarkerList=[];
			var times=0;
             

            var currentMilesText;
            var RecordMilesText;
			CurrenttotalMiles=0
            RecordtotalMiles=0;
            
            init();
			animate();





			function init() {

		   
				container = document.getElementById( 'container' );
             //   sceneRenderTarget = new THREE.Scene();
			//	camera = new THREE.PerspectiveCamera( 140, window.innerWidth / window.innerHeight,  1,100 );
			    camera = new THREE.PerspectiveCamera( 140, 1600/500,  1,1000 );
				//camera.position.set( -1200, 800, 1200 );
                camera.position.set(  0,6, 31);
             //   camera.position.set(  0, 25, 31);

			    controls = new THREE.OrbitControls( camera );
        
				scene = new THREE.Scene();
               
	            stop_Watch = document.createElement("div");
	            stop_Watch.className = "stopwatch";
	           // stop_Watch.style.zIndex =1; 
	            stop_Watch.style.position = 'absolute';
				//text2.style.zIndex = 1;    // if you still don't see the label, try uncommenting this
				stop_Watch.style.width = 20;
				stop_Watch.style.height= 10;
				stop_Watch.style.top =  window.innerHeight*0.1+ 'px';
				stop_Watch.style.left = window.innerWidth*0.479 + 'px';
				stop_Watch.align= "left";

	            document.body.appendChild(stop_Watch)
	            console.log(stop_Watch.innerHTML);
           // stop_Watch.className = "stopwatch";
             	parent = new THREE.Object3D();
				scene.add( parent );
				parent.position.set( 0,0,0);
                console.log(parent.position)

           		scene.fog = new THREE.FogExp2( 0x000000, 0.0150 );
           		 
              //   scene.fog = new THREE.Fog( 0x000000, 0, 80 );
			//	var data = generateHeight( dataW, dataH, perlinRandom);
			 	var ambient = new THREE.AmbientLight( 0xffffff,1.1);
                parent.add( ambient );

			    directionalLight = new THREE.DirectionalLight( 0xffffff, 1.15 );
				directionalLight.position.set( 500, 2000, 0 );
			//	scene.add( directionalLight );

				pointLight = new THREE.PointLight( 0xff4400, 1.5 );
				pointLight.position.set( 0, 0, 0 );
			//	scene.add( pointLight );


               // roadTex = THREE.ImageUtils.loadTexture("textures/lines/7.jpg");

                var groundMaterial = new THREE.MeshDepthMaterial({
        
    			});
                plane = new THREE.Mesh(new THREE.PlaneGeometry(50, 1000,10, 20), groundMaterial);
			    plane.rotation.x = -Math.PI / 2;
			    plane.receiveShadow = true;
			    plane.castShadow = true;
			    plane.position.set (0, 0, 0);


         //        roadMaterial = new THREE.MeshBasicMaterial( { 
		       //  color       : 0xffffff,
		       //  // map:  planeTex,
         //        wireframe : true,
		       // //  fog: 			true
		       //  } );

			    generateInfiniteLine()
				for(var i=0;i<passTotal;i++){	
				   	generateGroundLine( i, 0,CurrentroadCase,roadCase );		   	
				}

                generateCircle();

				renderer = new THREE.WebGLRenderer({ antialias: true });
				//renderer.autoClear = false
			   // renderer.setClearColor( scene.fog.color );
				renderer.setPixelRatio( window.devicePixelRatio );
			  	renderer.setSize( window.innerWidth, window.innerWidth*5/16);

			 // renderer.sortObjects = false;
				container.innerHTML = "";
                renderer.gammaInput = true;
				renderer.gammaOutput = true;

				container.appendChild( renderer.domElement );
      

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				//container.appendChild( stats.domElement );

                document.addEventListener( 'keydown', onKeyDown, false );

				//window.addEventListener( 'resize', onWindowResize, false );

			}
            function onKeyDown ( event ) {

				switch( event.keyCode ) {

					case 87: /*W*/  speed+=0.08; break;
					case 83: /*S*/  speed-=0.08; break;
					case 49:  /*1*/ if (roadCase!=1){ if(Percentage==1||Percentage==0){roadCase=1;Percentage=0;incrementer=0;}} break;
					case 50:  /*2*/ if (roadCase!=2){ if(Percentage==1||Percentage==0){roadCase=2;Percentage=0;incrementer=0;}} break;
					case 51:        if (roadCase!=3){ if(Percentage==1||Percentage==0){roadCase=3;Percentage=0;incrementer=0;}}break;

					case 52:  /*4*/ globalLineWidthAdd+=0.5; console.log(globalLineWidthAdd); break;
					case 53:        globalLineWidthAdd-=0.5; console.log(globalLineWidthAdd);break;

                //    case 54: /*6*/  if ( heightForceChange){smoothAdd=0.02; heightForceChange=!heightForceChange}else{ smoothAdd=-0.02 ;heightForceChange=!heightForceChange} break;

				}
               speed=THREE.Math.clamp(speed, 0,3) 
               GeneralLineW=THREE.Math.clamp(GeneralLineW, 0,50) 
			}
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}
         

			function generateCircle( ){

    		    uniforms = {

				      uTime: { type: 'f', value: 0.0 },
				      uFrontColor: { type: 'v4', value: new THREE.Vector4(1.0, 1.0, 1.0, 1.0)},
				      uBackColor: { type: 'v4', value: new THREE.Vector4(0.0, 0.0, 0.0, 0.0) },
				      uIsSolid: { type: 'f', value: 0.0 },
				      uHighlightCenter: { type: 'f', value: 0.0},
				      uNumOfMiles: { type: 'f', value: 0.0 },
				      uActiveDist: { type: 'f', value: 0.0 },
				      uRPM: { type: 'f', value: 0.0 },
				      uIntensity: { type: 'f', value: 0.5 },
				      uRotation: { type: 'f', value: 0.4 },
				      uTransparent: { type: 'f', value: 1.0 },
				      uMileStoneAnimTime: { type: 'f', value: 0.0 }
				};

 
                
                materialC = new THREE.ShaderMaterial({
                	  // wireframe:true,
                	  uniforms: uniforms,
     				  vertexShader: document.getElementById( 'vertexShader' ).textContent,
				      fragmentShader:document.getElementById( 'fragmentShader' ).textContent,
				      side: THREE.FrontSide,
     				  transparent: true
	      
				})
 

    			var californiaShape=  new THREE.PlaneGeometry(12, 12, 4,4)

                 

    			circle =  new THREE.Mesh( californiaShape,materialC);

    			//circlePast =  new THREE.Mesh( Circlepoints,MaterialCPast);

       

           
    //          circle = new THREE.Mesh(californiaShape, materialC )
         		circle.position.set( -4, 1.3 , 27.6);
                circle.scale.set(0.65,0.65,0.65 ); 
				circle.renderOrder =2;
                 scene.add(circle );

            }
            function MilesUpdate(totalMiles){

            	parent.remove(currentMilesText);
               	var textGeom = new THREE.TextGeometry(  totalMiles.toFixed(1)+' MI', {
               		color:0x00ff00,
			    	size :0.5,
					height:0.0,
			        font: 'graphik light' // Must be lowercase!
			    });
			     var textmaterial = new THREE.MeshBasicMaterial({
			        color: 0xffffff
			    });
			    currentMilesText = new THREE.Mesh( textGeom, textmaterial );
                textGeom.computeBoundingBox();
			    textGeom.textWidth = textGeom.boundingBox.max.x - textGeom.boundingBox.min.x;

			     currentMilesText.position.set(circle.position.x-textGeom.textWidth/2,circle.position.y-2.5,circle.position.z);
                parent.add(currentMilesText);
		 


            }

            function RecordMilesUpdate(totalMiles){
                parent.remove(RecordMilesText);
               	var textGeom = new THREE.TextGeometry(  totalMiles.toFixed(1)+' MI', {
               		color: 0x000000,
			    	size :0.5,
					height:0.0,
			        font: 'graphik light' // Must be lowercase!
			    });
			   var textmaterial = new THREE.MeshPhongMaterial({
			        color: 0x194ce6
			    });
			    RecordMilesText = new THREE.Mesh( textGeom, textmaterial );
                textGeom.computeBoundingBox();
			    textGeom.textWidth = textGeom.boundingBox.max.x - textGeom.boundingBox.min.x;

			    RecordMilesText.position.set(circlePast.position.x-textGeom.textWidth/2,circlePast.position.y-2.5,circlePast.position.z);
                parent.add(RecordMilesText);

            }

     
            
            


            function generateCirclePast(start,_offset){

	            uniformsPast = {
	            	  uTime: { type: 'f', value: 0.0 },
				      uFrontColor: { type: 'v4', value: new THREE.Vector4(0.1, 0.3, 0.9, 1.0)},
				      uBackColor: { type: 'v4', value: new THREE.Vector4(0.0, 0.0, 0.0, 0.0) },
				      uIsSolid: { type: 'f', value: 0.0 },
				      uHighlightCenter: { type: 'f', value: 0.0},
				      uNumOfMiles: { type: 'f', value: 0.0 },
				      uActiveDist: { type: 'f', value: 0.0 },
				      uRPM: { type: 'f', value: 0.0 },
				      uIntensity: { type: 'f', value: 0.5 },
				      uRotation: { type: 'f', value: 0.4 },
				      uTransparent: { type: 'f', value: 1.0 },
				      uMileStoneAnimTime: { type: 'f', value: 0.0 }
				};

 
                materialCPast = new THREE.ShaderMaterial({
                	  // wireframe:true,
                	  uniforms: uniformsPast,
     				  vertexShader: document.getElementById( 'vertexShaderPast' ).textContent,
				      fragmentShader:document.getElementById( 'fragmentShaderPast' ).textContent,
				      side: THREE.FrontSide,
     				  transparent: true
	      
				})
			 
    			var californiaShape=  new THREE.PlaneGeometry(12, 12, 4,4)
 
                circlePast =  new THREE.Mesh( californiaShape, materialCPast );

				circlePast.position.set( 4, 1.3, 27.5);
                circlePast.scale.set(0.65,0.65,0.65); 
				circlePast.renderOrder = 2;

			    scene.add(circlePast);

            }


    //         function generateBoard(start,_offset){

				// var  boardMaterial = new THREE.MeshBasicMaterial( { 
		  //         // color       : 0x000000,
		  //         map:  boardTex,
    //         //   alphaMap:boardTexAlpha,
		  //       transparent:true,
		  //       // fog: 			true
		  //       } );


		      


    //             console.log(boardTex)

    //             var boardShape=  new THREE.PlaneGeometry(100, 100, 4,4)
    // 			billBoard =  new THREE.Mesh( boardShape,boardMaterial);    			//circlePast =  new THREE.Mesh( Circlepoints,MaterialCPast);
    //      		billBoard.position.set( 0, 16, 3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset);
    //           // 	billBoard.scale.set(1.3,0.3,0.3 ); 
				// billBoard.renderOrder = 1;
    //             billBoardList.push(billBoard)
				// scene2.add(billBoard)
 

    //         }

            function generateInfiniteLine(  ){
                var roadLineWidth=1.5
                var geometrylineL = new THREE.Geometry();
                geometrylineL.vertices.push(new THREE.Vector3(0, 0, 0))	;
				geometrylineL.vertices.push(new THREE.Vector3(0, 0, -800))	;

                var lineMaterial=new THREE.LineBasicMaterial( {
						color: 0xffffff,
						opacity: 1,
						linewidth: 1+globalLineWidthAdd,
						//transparent:true,
						fog:true
				} )  
                   
                var curvetempL  = new THREE.Line( geometrylineL , lineMaterial)
				curvetempL.position.set (  -dataW*scaleW/2, 0, 2.5*(dataH*scaleH)); 
				curvetempL.renderOrder = -6;
			    parent.add( curvetempL);

                var curvetempL  = new THREE.Line( geometrylineL , lineMaterial)
				curvetempL.position.set (  -dataW*scaleW/2+roadLineWidth, 0, 2.5*(dataH*scaleH)); 
				curvetempL.renderOrder = -6;
			    parent.add( curvetempL);

                
				var GateMaterial= new THREE.MeshBasicMaterial( {
                 color: 0xffFFFF ,
                 side:THREE.DoubleSide,
                 fog:true
                } )

                var geom = new THREE.Geometry(); 
				var v1 = new THREE.Vector3(0,0,0);
				var v2 = new THREE.Vector3(roadLineWidth,0, 0);
				var v3 = new THREE.Vector3(roadLineWidth,0, -800);
                var v4 = new THREE.Vector3(0,0,-800);

				geom.vertices.push(v1);
				geom.vertices.push(v2);
				geom.vertices.push(v3);
                geom.vertices.push(v4);
  
                geom.faces.push( new THREE.Face3( 0, 1, 2 ) );
                geom.faces.push( new THREE.Face3( 0, 2, 3 ) );
                var meshtempRoad= new THREE.Mesh( geom, GateMaterial) ;
                meshtempRoad.position.set ( -dataW*scaleW/2, 0,  2.5*(dataH*scaleH)); 
 
				meshtempRoad.renderOrder =  8;
                parent.add(meshtempRoad);
				roadMeshList.push(meshtempRoad)


                var curvetempR  = new THREE.Line( geometrylineL , lineMaterial)
				curvetempR.position.set (   dataW*scaleW/2, 0, 2.5*(dataH*scaleH)); 
				curvetempR.renderOrder = -6;
			    parent.add( curvetempR);

				var curvetempR  = new THREE.Line( geometrylineL , lineMaterial)
				curvetempR.position.set (   dataW*scaleW/2-roadLineWidth, 0, 2.5*(dataH*scaleH)); 
				curvetempR.renderOrder = -6;
			    parent.add( curvetempR);
            	  
                var geom = new THREE.Geometry(); 
				var v1 = new THREE.Vector3(0,0,0);
				var v2 = new THREE.Vector3(-roadLineWidth,0, 0);
				var v3 = new THREE.Vector3(-roadLineWidth , 0, -800);
                var v4 = new THREE.Vector3(0,0,-800);

				geom.vertices.push(v1);
				geom.vertices.push(v2);
				geom.vertices.push(v3);
                geom.vertices.push(v4);
  
                geom.faces.push( new THREE.Face3( 0, 1, 2 ) );
                geom.faces.push( new THREE.Face3( 0, 2, 3 ) );
                var meshtempRoad= new THREE.Mesh( geom, GateMaterial) ;
                meshtempRoad.position.set ( dataW*scaleW/2, 0, 2.5*(dataH*scaleH)); 
 
				meshtempRoad.renderOrder =  8;
                parent.add(meshtempRoad);
				roadMeshList.push(meshtempRoad) 
		     
            }

             function generateMileMarker(_times){
                 var miles=(times/40).toFixed(1)
                // ("" +times/20).slice(0,-2);   
              
                 var textmaterial = new THREE.MeshPhongMaterial({
			        color: 0xffffff
			    });
			    var textGeom = new THREE.TextGeometry(  miles+' Miles', {
			    	size :6.0,
					height:0.0,
			        font: 'graphik black' // Must be lowercase!
			    });
			    var textMesh = new THREE.Mesh( textGeom, textmaterial );

			    textGeom.computeBoundingBox();
			    textGeom.textWidth = textGeom.boundingBox.max.x - textGeom.boundingBox.min.x;
			    
			    pivot = new THREE.Object3D();
				pivot.add( textMesh);

				textMesh.rotation.x  =- Math.PI/2;

			    pivot.position.set(0-textGeom.textWidth/2,0,0);
                parent.add(pivot);
			    mileMarkerList.push(pivot)
			    
             }

             function generateGroundLine(start , _offset , curCase, Case ){
            	if (!_offset){
            	   	_offset=0;
            	}
                 
                var counter=0;          

                var lineMaterial=new THREE.LineBasicMaterial( {
						color: 0xA0A0A0,
						opacity: 1,
						linewidth:1+globalLineWidthAdd,
						transparent:true,
						fog:true
 
				} )  

				var GateMaterial= new THREE.MeshBasicMaterial( {
                 color: 0xffFFFF ,
                 side:THREE.DoubleSide,
                 fog:true
                } )


                var meshWidth=0.3;

                if (curCase==1 && Case==1){
                case12(1)
              
                }else if(curCase==1 && Case==2){
                  incrementer += 1;
                  Percentage += Math.pow(1.2, incrementer)*0.026;
                  console.log(roadCase,Percentage)
                  Percentage=THREE.Math.clamp(Percentage,0,1);
                  case12(1-Percentage)
               
                }else if(curCase==1 && Case==3){
                  incrementer += 1;
                  Percentage += Math.pow(1.05, incrementer)*0.042;
                   if (Percentage<0.3){
                  	Percentage=0.3
                  }
                  console.log(roadCase,Percentage)
                  Percentage=THREE.Math.clamp(Percentage,0,1);
                  case13( 1-Percentage)

                }else if(curCase==2 && Case==1){
                  incrementer += 1;
                  Percentage += Math.pow(1.2, incrementer)*0.026;
                  console.log(roadCase,Percentage)
                  Percentage=THREE.Math.clamp(Percentage,0,1);
                  case12(Percentage)
                }else if(curCase==2 && Case==2){
                  case12(0);
                }else if(curCase==2 && Case==3){
                  incrementer += 1;
                  Percentage += Math.pow(1.1, incrementer)*0.03;
                    if (Percentage<0.3){
                  		Percentage=0.3
                  	}
                  console.log(roadCase,Percentage)
                  Percentage=THREE.Math.clamp(Percentage,0,1);
                  case23(1-Percentage)
                }else if(curCase==3 && Case==1){
                  incrementer += 1;
                  Percentage += Math.pow(1.2, incrementer)*0.024;
                  console.log(roadCase,Percentage)
                  Percentage=THREE.Math.clamp(Percentage,0,1);
                  case13( Percentage)
                }else if(curCase==3 && Case==2){
                  incrementer += 1;
                  Percentage += Math.pow(1.4, incrementer)*0.044;
                  console.log(roadCase,Percentage)
                  Percentage=THREE.Math.clamp(Percentage,0,1);
                  case23( Percentage)
                }else if(curCase==3 && Case==3){
               	  case23(0)
                }

                function case12( _Percentage){
                ang= Math.PI / 2* _Percentage;
              
                var geometryGateLine=new THREE.Geometry();
               // var geometryGateLine=[];
				geometryGateLine.vertices.push(new THREE.Vector3(0, 0, 0))	;
                geometryGateLine.vertices.push(new THREE.Vector3(1600*Math.sin(-ang), 1600*Math.cos(ang), 0));

                generateGroundLine(geometryGateLine , lineMaterial,  -dataW*scaleW/2, 0, 3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset)
	            generateGroundLine(geometryGateLine , lineMaterial, -dataW*scaleW/2, 0, 3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset-meshWidth)

                var geom = new THREE.Geometry(); 
				var v1 = new THREE.Vector3(0,0,0);
				var v2 = new THREE.Vector3(1600*Math.sin(-ang),1600*Math.cos(ang), 0);
				var v3 = new THREE.Vector3(1600*Math.sin(-ang),1600*Math.cos(ang), -meshWidth);
                var v4 = new THREE.Vector3(0,0,-meshWidth);

				geom.vertices.push(v1,v2,v3,v4);
                geom.faces.push( new THREE.Face3( 0, 1, 2 ), new THREE.Face3( 0, 2, 3 ) );

                var rectMesh = new THREE.Mesh( geom, GateMaterial) ;
                rectMesh.position.set ( -dataW*scaleW/2, 0,  3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset); 
                Gates.push(rectMesh)
                parent.add(rectMesh);


        		var geometryGateLine=new THREE.Geometry();
				geometryGateLine.vertices.push(new THREE.Vector3(0, 0, 0))	;
              //  geometryGateLine.vertices.push(new THREE.Vector3(640, 0, 0))	;
                geometryGateLine.vertices.push(new THREE.Vector3(1600*Math.sin(ang), 1600*Math.cos(ang), 0));


                var  groundLine  = new THREE.Line( geometryGateLine , lineMaterial)
				groundLine.position.set ( dataW*scaleW/2, 0, 3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset); 
			    groundLines.push(groundLine)
			    parent.add( groundLine);
			    groundLine .renderOrder = -16;

			     var  groundLine  = new THREE.Line( geometryGateLine , lineMaterial)
				groundLine.position.set ( dataW*scaleW/2, 0, 3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset-meshWidth); 
			    groundLines.push(groundLine)
			    parent.add( groundLine);
			    groundLine .renderOrder = -16;
                

                var geom = new THREE.Geometry(); 
				var v1 = new THREE.Vector3(0,0,0);
				var v2 = new THREE.Vector3(1600*Math.sin(ang),1600*Math.cos(ang), 0);
				var v3 = new THREE.Vector3(1600*Math.sin(ang),1600*Math.cos(ang), -meshWidth);
                var v4 = new THREE.Vector3(0,0,-meshWidth);

				geom.vertices.push(v1,v2,v3,v4);
  
                geom.faces.push( new THREE.Face3( 0, 1, 2 ),new THREE.Face3( 0, 2, 3 ) );

                var rectMesh = new THREE.Mesh( geom, GateMaterial) ;
                rectMesh.position.set ( dataW*scaleW/2, 0,  3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset); 
                Gates.push(rectMesh)
                parent.add(rectMesh);

                }
                

                function case23( _Percentage){
                
	                var geometryGateLine=new THREE.Geometry();

					geometryGateLine.vertices.push(new THREE.Vector3(0, 0, 0))	;
	                geometryGateLine.vertices.push(new THREE.Vector3(0, 40+280*_Percentage, 0));
	                geometryGateLine.vertices.push(new THREE.Vector3(dataW*scaleW/2+1, 40+280*_Percentage,0));

					generateGroundLine(geometryGateLine , lineMaterial, -dataW*scaleW/2, 0,  3*(dataH*scaleH)+ (-dataH*scaleH)*start+_offset)
	                generateGroundLine(geometryGateLine , lineMaterial, -dataW*scaleW/2, 0, 3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset-meshWidth)

	                var geom = new THREE.Geometry(); 
					var v1 = new THREE.Vector3(0,0,0);
					var v2 = new THREE.Vector3(0, 40+280*_Percentage, 0);
					var v3 = new THREE.Vector3(0, 40+280*_Percentage, -meshWidth);
	                var v4 = new THREE.Vector3(0,0,-meshWidth);
	                var v5 = new THREE.Vector3(dataW*scaleW/2+1, 40+280*_Percentage,0);
	                var v6 = new THREE.Vector3(dataW*scaleW/2+1, 40+280*_Percentage,-meshWidth);

					geom.vertices.push(v1,v2,v3,v4,v5,v6);

	                geom.faces.push( 
		                new THREE.Face3( 0, 1, 2 ),
		                new THREE.Face3( 0, 2, 3 ),
		                new THREE.Face3( 1, 2, 5 ),
		                new THREE.Face3( 4, 1, 5 ) 
	                );
	                var rectMesh = new THREE.Mesh( geom, GateMaterial) ;
	                rectMesh.position.set ( -dataW*scaleW/2, 0,  3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset); 
	                Gates.push(rectMesh)
	                parent.add(rectMesh);

	                var geometryGateLine=new THREE.Geometry();

					geometryGateLine.vertices.push(new THREE.Vector3(0, 0, 0))	;
	                geometryGateLine.vertices.push(new THREE.Vector3(0, 40+280*_Percentage,0));
	                geometryGateLine.vertices.push(new THREE.Vector3(-dataW*scaleW/2,40+280*_Percentage,0));

	                generateGroundLine(geometryGateLine , lineMaterial, dataW*scaleW/2, 0, 3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset)
	                generateGroundLine(geometryGateLine , lineMaterial, dataW*scaleW/2, 0, 3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset-meshWidth)

	                var geom = new THREE.Geometry(); 
					var v1 = new THREE.Vector3(0,0,0);
					var v2 = new THREE.Vector3(0, 40+280*_Percentage, 0);
					var v3 = new THREE.Vector3(0, 40+280*_Percentage, -meshWidth);
	                var v4 = new THREE.Vector3(0,0,-meshWidth);
	                var v5 = new THREE.Vector3(-dataW*scaleW/2+1, 40+280*_Percentage,0);
	                var v6 = new THREE.Vector3(-dataW*scaleW/2+1, 40+280*_Percentage,-meshWidth);

					geom.vertices.push(v1,v2,v3,v4,v5,v6);

	                geom.faces.push( 
	                	new THREE.Face3( 0, 1, 2 ), 
	                  	new THREE.Face3( 0, 2, 3 ),
	               		new THREE.Face3( 1, 2, 5 ), 
	               		new THREE.Face3( 4, 1, 5 ) 
	                )

	                var rectMesh = new THREE.Mesh( geom, GateMaterial) ;
	                rectMesh.position.set ( dataW*scaleW/2, 0,  3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset); 
	                Gates.push(rectMesh)
	                parent.add(rectMesh);

 				}


                function case13( _Percentage){
                
	                var geometryGateLine=new THREE.Geometry();

					geometryGateLine.vertices.push(new THREE.Vector3(0, 0, 0));
					geometryGateLine.vertices.push(new THREE.Vector3(-1200*_Percentage, 0, 0));
	                geometryGateLine.vertices.push(new THREE.Vector3(-1200*_Percentage, 40+280*_Percentage, 0));
	                geometryGateLine.vertices.push(new THREE.Vector3(dataW*scaleW/2+1, 40+280*_Percentage,0));
	 
					generateGroundLine(geometryGateLine , lineMaterial,  -dataW*scaleW/2, 0,  3*(dataH*scaleH)+ (-dataH*scaleH)*start+_offset)
	                generateGroundLine(geometryGateLine , lineMaterial, -dataW*scaleW/2, 0, 3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset-meshWidth)

	                var geom = new THREE.Geometry(); 
					var v1 = new THREE.Vector3(0,0,0);
					var v2 = new THREE.Vector3(-1200*_Percentage, 0, 0);
					var v3 = new THREE.Vector3(-1200*_Percentage, 0, -meshWidth);
	                var v4 = new THREE.Vector3(0,0,-meshWidth);
	                var v5 = new THREE.Vector3(-1200*_Percentage, 40+280*_Percentage,0);
	                var v6 = new THREE.Vector3(-1200*_Percentage, 40+280*_Percentage,-meshWidth);       
	                var v7 = new THREE.Vector3(dataW*scaleW/2+1, 40+280*_Percentage,0);
	                var v8 = new THREE.Vector3(dataW*scaleW/2+1, 40+280*_Percentage,-meshWidth);

					geom.vertices.push(v1,v2,v3,v4,v5,v6,v7,v8);

	                geom.faces.push( 
		                new THREE.Face3( 0, 1, 2 ),
		               	new THREE.Face3( 0, 2, 3 ),
		               	new THREE.Face3( 1, 2, 5 ),
		                new THREE.Face3( 4, 1, 5 ),
		                new THREE.Face3( 4, 5, 7 ),
		                new THREE.Face3( 4, 7, 6) 
	                );

	                var rectMesh = new THREE.Mesh( geom, GateMaterial) ;
	                rectMesh.position.set ( -dataW*scaleW/2, 0,  3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset); 
	                Gates.push(rectMesh)
	                parent.add(rectMesh);

	                var geometryGateLine=new THREE.Geometry();
	 
					geometryGateLine.vertices.push(new THREE.Vector3(0, 0, 0))	;
					geometryGateLine.vertices.push(new THREE.Vector3(1200*_Percentage, 0, 0));
	                geometryGateLine.vertices.push(new THREE.Vector3(1200*_Percentage, 40+280*_Percentage,0));
	                geometryGateLine.vertices.push(new THREE.Vector3(-dataW*scaleW/2,40+280*_Percentage,0));


	                generateGroundLine(geometryGateLine , lineMaterial,  -dataW*scaleW/2, 0, dataW*scaleW/2, 0, 3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset)
	                generateGroundLine(geometryGateLine , lineMaterial,  dataW*scaleW/2, 0, 3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset-meshWidth)

	                var geom = new THREE.Geometry(); 
					var v1 = new THREE.Vector3(0,0,0);
					var v2 = new THREE.Vector3(1200*_Percentage, 0, 0);
					var v3 = new THREE.Vector3(1200*_Percentage, 0, -meshWidth);
	                var v4 = new THREE.Vector3(0,0,-meshWidth);
	                var v5 = new THREE.Vector3(1200*_Percentage, 40+280*_Percentage,0);
	                var v6 = new THREE.Vector3(1200*_Percentage, 40+280*_Percentage,-meshWidth);       
	                var v7 = new THREE.Vector3(-dataW*scaleW/2+1, 40+280*_Percentage,0);
	                var v8 = new THREE.Vector3(-dataW*scaleW/2+1, 40+280*_Percentage,-meshWidth);

					geom.vertices.push(v1,v2,v3,v4,v5,v6,v7,v8);

	                geom.faces.push( 
		                new THREE.Face3( 0, 1, 2 ),
		               	new THREE.Face3( 0, 2, 3 ),
		               	new THREE.Face3( 1, 2, 5 ),
		                new THREE.Face3( 4, 1, 5 ),
		                new THREE.Face3( 6, 4, 5 ),
		                new THREE.Face3( 6, 5, 7 ) 
	                );

	                var rectMesh = new THREE.Mesh( geom, GateMaterial) ;
	                rectMesh.position.set ( dataW*scaleW/2, 0,  3*(dataH*scaleH)+  (-dataH*scaleH)*start+_offset); 
	                Gates.push(rectMesh)
					parent.add(rectMesh);


                }

                function generateGroundLine(_geometryGateLine , _lineMaterial, _x,_y,_z){
                    var groundLine  = new THREE.Line( _geometryGateLine , _lineMaterial)
	                groundLine.position.set ( _x, _y, _z); 
				    groundLines.push(groundLine)
				    parent.add( groundLine);
					groundLine .renderOrder = -16;

				}
	
               }

			function animate() {
				requestAnimationFrame( animate );
				render();
				//stats.update();
			}
          
			function render() {
			  	var delta = clock.getDelta();
   

               	MilesUpdate(CurrenttotalMiles)
           	 	if (typeof(circlePast) !== 'undefined'){
            		RecordMilesUpdate(RecordtotalMiles)
                }
           
                speed=THREE.Math.clamp(speed,0,2)

              

	            if (Stopwatch.check()==timePeriod[roundCount]){  
		            Stopwatch.restart();
		            recordList.push(recordTemp)
		            recordTemp=0;
		            smoothAdd=-0.02
	                roundCount=(roundCount+1)%timePeriod.length;
	                console.log(Stopwatch.check())
	                	  
	            }
                    

                recordTemp+=speed;


	            for(var i in groundLines){ 
		                 // curveL[i].translateZ(delta *speed*25);
		                 // curveR[i].translateZ(delta *speed*25);
		            groundLines[i].translateZ(delta *speed*25);
		               
	      
		        }
		        for(var i in Gates){ 
					Gates[i].translateZ(delta *speed*25);
		        }
	 			for(var i in mileMarkerList){ 
					mileMarkerList[i].translateZ(delta *speed*25);
		        }
 

	             //  for(var i in roadMeshList){ 
	             //    roadMeshList[i].translateZ(delta *speed*25);
	             // }

                 
	            if (billBoardList[0]){

	                billBoardList[0].translateZ(delta *speed*25);
	                   
					    if (billBoardList[0].position.z>=camera.position.z){
					      	console.log("Go team!")
							Stopwatch.restart();
							scene.remove(billBoardList[0]);
							billBoardList.shift();
					    }
	                }
 
	            uniforms.uRPM.value  = 0.1+speed;
	            uniforms.uRotation.value +=delta * (0.01+speed*1)*1.0;
	                
	            uniforms.uIntensity.value =((speed-0.0)+0.1)*300.0 ;	
 
               //|||| circlePast != null
                 
	            if (typeof circlePast != 'undefined' ){
	    
	                var temp= Math.abs(1/(circlePast.position.z-circle.position.z))*0.01 
	                temp= Math.pow(temp,2)*(speed-defaultSpeed)
	                temp=THREE.Math.clamp(temp,-0.0001,0.0001)

	                uniformsPast.uRPM.value  = 0.1+speed+(Math.random()-0.5);
	                uniformsPast.uRotation.value +=delta * (0.01+speed*1)*1.0;
	                uniformsPast.uIntensity.value =((speed-0.0)+0.1)*300.0 +temp*1000;

	                var Pass=circle.position.z-circlePast.position.z;
	                if ((Pass>-0.1)&&(Pass<0.1)){
	 			//	 uniformsPast.stroke.value=0.1+(0.2-Math.abs(Pass))*10;
	             //    uniformsPast.stroke.value=THREE.Math.clamp(uniformsPast.stroke.value,0.1,3)
	                 //console.log("pass")
	                uniformsPast.uHighlightCenter.value=(0.1-Math.abs(Pass))*10.0;
	                uniformsPast.uHighlightCenter.value=THREE.Math.clamp(uniformsPast.uHighlightCenter.value,0.0,1.0)
            
                 	}
				
	                circlePast.translateZ(delta* (Math.random()-0.5)*0.2)
	                circlePast.position.z +=delta *temp*1000;
	                circlePast.position.z +=delta *(speed-defaultSpeed)*0.0015;
                 // circlePast.position.z +=delta *  1/  (Math.abs((circlePast.position.z-circle.position.z)*3))

                    circlePast.position.z=THREE.Math.clamp(circlePast.position.z,10, 28)
              //    console.log(circlePast.position.z)
				}
					
                
	            if (groundLines[0].position.z>=passCount*dataH*scaleH){

                        times++;
                        if (times%4==0){
                        	CurrenttotalMiles+=0.1
            	 			RecordtotalMiles+=0.1; 
                        }

		 				if (CurrentroadCase!=roadCase){
		                         
		                }

			            reset=true;
			            var offset_adj=groundLines[0].position.z-passCount*dataH*scaleH   
                         
		                generateGroundLine(passTotal-passCount+3,offset_adj,CurrentroadCase,roadCase);
                         
                        if (countdown==1){
                          //  generateBoard(passTotal-passCount+3,offset_adj);
                            countdown=0;
                            roundCount=(roundCount+1)%timePeriod.length;

                        }

                        if ((recordList.length>0)&&(typeof circlePast === 'undefined' )){
                         	console.log()
							generateCirclePast( passTotal-passCount+3, offset_adj )
						}

		                if (Percentage==1){
		                	CurrentroadCase=roadCase;
		                }

		                if (groundLines[0]){
                             
				            for(var j=0;j<4;j++){
				               parent.remove( groundLines[0])
				               groundLines.shift();

				             }
                            for(var j=0;j<2;j++){
				               parent.remove( Gates[0])
				               Gates.shift();
				             }
			            }

			            if ((times>18)&&(times%20==19)){
                            if (mileMarkerList.length>0){
 								parent.remove(mileMarkerList[0])
                            	mileMarkerList.shift();
                            }                    
                            generateMileMarker(times);                           
			            }

	            }

                    camera.lookAt( new THREE.Vector3(0,camera.position.y, -100));
				 //  renderer.clear();
				  	renderer.render( scene, camera );
				//  renderer.clearDepth();
				//  renderer.render( scene2, camera );

				 
			}
        

   //       startTimer(fiveMinutes, display);

		 // function startTimer(duration, display) {
		 //    var diff,
		 //        minutes,
		 //        seconds;
		 //    function timer() {
		 //        // get the number of seconds that have elapsed since 
		 //        // startTimer() was called
		 //        diff = duration - ((delta) / 1000) | 0);

		 //        // does the same job as parseInt truncates the float
		 //        minutes = (diff / 60) | 0;
		 //        seconds = (diff % 60) | 0;

		 //        minutes = minutes < 10 ? "0" + minutes : minutes;
		 //        seconds = seconds < 10 ? "0" + seconds : seconds;

		 //        display.textContent = minutes + ":" + seconds; 

		 //        if (diff <= 0) {
		 //            start = Date.now() + 1000;
		 //        }
		 //    };
		   
		 
		     
		//}

		</script>

        <script src="js/stopwatch.js"></script>
		 

	</body>
</html>
